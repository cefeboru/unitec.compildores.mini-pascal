import java_cup.runtime.*;
import java.util.List;


parser code {:
        @Override
	public void report_error(String message, Object info) {
            
            if (info instanceof String)
                    System.err.println(" " + info + " " + message + "\n");
            else {
                    StringBuffer m = new StringBuffer("Error ");
                    if (info instanceof java_cup.runtime.Symbol) {
                        m.append(("(Se ha encontrado el token \"" + ((Symbol)info).value + "\" en la linea "
                            + ((Symbol)info).left + 1 + ", columna " + ((Symbol)info).right + " " + 1) + ")");
                    }
                    if (message.equals("Couldn't repair and continue parse"))
                        m.append(" : No existe una regla por los momentos para este token.");
                    else
                        m.append(" : " + message);
                    System.err.println(m);
            }
        }

        @Override
	public void syntax_error(Symbol s){
            System.err.println( "(Se ha encontrado el token \"" + sym.terminalNames[s.sym] + "\" en la linea " + (s.left+1) + ", columna" + (s.right+1) + ")" ); 
            expected();
        }

        public void expected(){
            List<Integer> token_list = this.expected_token_ids();
            if (token_list.size() <= 0){
                    token_list = this.expected_token_ids();
            }
            String expected_tokens = "";
            for (int i = 0 ; i < token_list.size(); i++){
                    int id = token_list.get(i);
                    if (id == 1){
                            continue;
                    }
                    String terminal_name = sym.terminalNames[id];
                    if (i == token_list.size() - 1){
                            expected_tokens += terminal_name;
                    }else{
                            expected_tokens += terminal_name + " , ";
                    }
            }
            System.err.println("Se esperaba alguno de los siguientes tokens:" + expected_tokens);
        };

        public void report_fatal_error(String message, Object info) {
            report_error(message, info);
            throw new RuntimeException("Fatal Syntax Error");
        }
:};


/* Terminals (tokens returned by the scanner). */
//Funciones
terminal Write;
terminal Read;

//Tipos de datos
terminal Array;
terminal Of;
terminal Tipo;
terminal Var;
terminal TipoBoolean;
terminal TipoChar;
terminal TipoInteger;
terminal TipoString;

//Operadores
terminal OperadorIgual;
terminal OperadorDiferente;
terminal OperadorMayor;
terminal OperadorMenor;
terminal OperadorMayorIgual;
terminal OperadorMenorIgual;
terminal OperadorAnd;
terminal OperadorOr;
terminal OperadorNot;
terminal OperadorSuma;
terminal OperadorResta;
terminal OperadorMultiplicacion;
terminal OperadorMod;
terminal OperadorDivision;
terminal OperadorDivisionSpecial;

//Estructuras de control
terminal If;
terminal Then;
terminal Else;
terminal ElseIf;
terminal Begin;
terminal End;
terminal For;
terminal To;
terminal Do;
terminal While;
terminal Repeat;
terminal Until;

//Otros
terminal BracketAbrir;
terminal BracketCerrar;
terminal ComillaSimple;
terminal ComillaDentro;
terminal Coma;
terminal Digito;
terminal DosPuntos;
terminal DosPuntosIgual;
terminal Identificador;
terminal Letra;
terminal LineTerminator;
terminal LlaveAbrir;
terminal LlaveCerrar;
terminal ParentesisAbrir;
terminal ParentesisCerrar;
terminal Program;
terminal Procedure;
terminal Function;
terminal Punto;
terminal PuntoComa;
terminal PuntoPunto;
terminal WhiteSpace;

/*Literales*/
terminal java.lang.Number       LiteralEntero;
terminal java.lang.Character    LiteralCaracter;
terminal java.lang.Boolean      LiteralBoolean;
terminal java.lang.String       LiteralString;

/* Non terminals */
nonterminal             expr_list;
nonterminal Integer     expr;      // used to store evaluated subexpressions
nonterminal             literal;
nonterminal             program;
nonterminal             block;
nonterminal             blockProc;
nonterminal             identifier;
nonterminal             decls;
nonterminal             decl;
nonterminal             typedecl;
nonterminal             vardecls;
nonterminal             vardecl;
nonterminal             procdecls;
nonterminal             procdecl;
nonterminal             forstmt;
nonterminal             varFor;

nonterminal             functionDecl;
nonterminal             inlineArgs;
nonterminal             inlineArg;
nonterminal             procedureDecl;
nonterminal             procInlineDecls;
nonterminal             procInlineDecl;

nonterminal             type;
nonterminal             identtype;
nonterminal             arraytype;
nonterminal             arrayidenttype;
nonterminal             vars;
nonterminal             var;
nonterminal             expresions;
nonterminal             opexpr;

nonterminal             exprlist;
nonterminal             opRelacion;
non terminal            opSuma;
non terminal            opUnario;
nonterminal             stmts;
nonterminal             stmt;
nonterminal             assignstmt;
nonterminal             ifstmt;
non terminal            whilestmt;
non terminal            repeatstmt;

non terminal            writestmt;
non terminal            readstmt;


nonterminal             integer;
nonterminal             character;
nonterminal             boolean;
nonterminal             string;


/*-* Operator Precedences **/
precedence right DosPuntosIgual;
precedence left OperadorIgual, OperadorMenor, OperadorMayor, OperadorMenorIgual, OperadorMayorIgual, OperadorDiferente;
precedence left OperadorSuma, OperadorResta, OperadorOr;
precedence left OperadorMultiplicacion, OperadorDivision, OperadorMod, OperadorDivisionSpecial, OperadorAnd;

precedence left Else, PuntoComa;

program         ::= Program Identificador:i PuntoComa block:b Punto
                ;

block           ::= decls:d Begin stmts:s End
                        {:  :}
                ;

blockProc       ::= procInlineDecls Begin stmts:s End
                ;

decls           ::= /* empty */
                |   decl:d decls:ds
                ;

decl            ::= Var vardecls:vd
                |   functionDecl
                |   procedureDecl
                ;

functionDecl    ::= Function Identificador:i ParentesisAbrir inlineArgs ParentesisCerrar DosPuntos type PuntoComa blockProc:b PuntoComa
                |   Function Identificador:i ParentesisAbrir ParentesisCerrar DosPuntos type PuntoComa blockProc:b PuntoComa
                ;

procedureDecl   ::= Procedure Identificador:i ParentesisAbrir inlineArgs ParentesisCerrar PuntoComa blockProc:b PuntoComa
                |   Procedure Identificador:i ParentesisAbrir ParentesisCerrar PuntoComa blockProc:b PuntoComa
                ;

procInlineDecls  ::= 
                |   procInlineDecl procInlineDecls
                ;

procInlineDecl  ::= Var vardecls:vd
                ;


inlineArgs      ::= inlineArg
                |   inlineArg PuntoComa inlineArgs
                ;

inlineArg       ::= Var vars:vs DosPuntos identtype
                |       vars:vs DosPuntos identtype 
                ;

vardecls        ::= /* Empty */
                |  vardecl PuntoComa vardecls
                ;

vardecl         ::= vars:vs DosPuntos type:t
                ;

vars            ::= var:v
                        {:  :}
                |   var:v Coma vars:vs
                        {:  :}
                ;

var             ::= Identificador:i
                    {: :}
                ;

type            ::= identtype:it
                |   arraytype:ats
                ;

identtype       ::= TipoChar
                |   TipoString
                |   TipoBoolean
                |   TipoInteger
                ;

arrayidenttype  ::= TipoChar
                |   TipoBoolean
                |   TipoInteger
                ;

arraytype       ::= Array BracketAbrir integer:i BracketCerrar Of arrayidenttype:t
                        {:  :}
                ;

stmts           ::= stmt:s
                        {: :}
                | stmt:s PuntoComa stmts:ss
                        {: :}
                ;

stmt            ::= /* Empty */
                | assignstmt:as
                | ifstmt:is
                | forstmt
                | whilestmt
                | repeatstmt
                | readstmt
                | writestmt
                ;

assignstmt      ::= Identificador:i DosPuntosIgual expr:e 
                ;

ifstmt          ::= If expr:e Then stmt:s Else stmt:s2
                |   If expr:e Then stmt:s
                ;

forstmt         ::= For assignstmt:a To expr:e2 Do stmts:s
                ;

whilestmt       ::= While expr:e Do stmt:s
                ;

repeatstmt      ::= Repeat stmts:s Until expr:e
                ;

writestmt       ::= Write ParentesisAbrir string:s ParentesisCerrar
                |   Write ParentesisAbrir string:s Coma string ParentesisCerrar
                |   Write ParentesisAbrir string:s Coma character ParentesisCerrar
                |   Write ParentesisAbrir string:s Coma integer ParentesisCerrar
                ;

readstmt        ::= Read ParentesisAbrir string:s ParentesisCerrar
                ;

expr            ::= literal
                |   var
                |   var:v ParentesisAbrir exprlist:el ParentesisCerrar
                |   expr opRelacion expr
                |   expr opSuma expr
                |   opUnario expr
                |   ParentesisAbrir expr ParentesisCerrar
                ;

opRelacion      ::= OperadorIgual
                |   OperadorDiferente
                |   OperadorMayor
                |   OperadorMenor
                |   OperadorMenorIgual
                |   OperadorMayorIgual
                ;


opSuma          ::= OperadorSuma
                |   OperadorResta
                |   OperadorOr
                ;

opUnario        ::= OperadorNot
                |   OperadorSuma
                |   OperadorResta
                ;

exprlist        ::= expr
                |   expr Coma exprlist
                ;

literal         ::= integer
                |   character
                |   boolean
                |   string
                ;

integer         ::= LiteralEntero:i 
                    {: :}
                ;

character       ::= LiteralCaracter:c
                    {:  :}
                ;

boolean         ::= LiteralBoolean:b
                    {:  :}
                ;

string          ::= LiteralString:s
                    {:  :}
                ;